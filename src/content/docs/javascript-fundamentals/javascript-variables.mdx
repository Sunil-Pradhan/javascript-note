---
title: JavaScript Variables
description: Variables in JavaScript are like containers that store data values. You can use them to store numbers, strings, arrays, objects, or even functions.

tableOfContents:
  minHeadingLevel: 2
  maxHeadingLevel: 4

sidebar:
  # Add a badge to the link
  badge:
    text: New
    variant: note
---

import { Aside } from '@astrojs/starlight/components';
import { Badge } from '@astrojs/starlight/components';

#### ğŸ§  What is a Variable in JavaScript?

A `variable` is a container for storing data values like numbers, strings, arrays, objects, etc.

In JavaScript, you can declare variables using:

- `var` (old way)
- `let` (ES6 â€“ modern)
- `const` (ES6 â€“ modern)

#### ğŸ§“ `var` â€“ The Old School Way

##### ğŸ“Œ Point 1: `var` is Function Scoped

When you use `var`, the variable is only available **inside the function** where you declared it. If you declare it **outside** of any function, it becomes **global** (available everywhere).

###### ğŸ§ª Example: `var` inside a function

```js
function sayHello() {
  var greeting = 'Hello!';
  console.log(greeting); // âœ… This works
}

sayHello();
// console.log(greeting); âŒ Error: greeting is not defined
```

ğŸ’¡ `greeting` only exists inside the function `sayHello`. You can't access it outside.

###### ğŸ§ª Example: `var` outside any function

```js
var globalVar = 'I am global';

function checkScope() {
  console.log(globalVar); // âœ… I am global
}

checkScope();
console.log(globalVar); // âœ… I am global
```

ğŸ’¡ Because `globalVar` is declared outside a function, it can be used **anywhere**.

##### ğŸ“Œ Point 2: `var` Ignores Curly Braces (Not Block Scoped)

When you use `var` **inside curly braces** like in `if`, `for`, or `{ }`, the variable **doesn't stay inside** that block. It "leaks out" and can be used **outside** the block.

Thatâ€™s because `var` does **not** have **block-level scope** â€“ it only cares about functions.

###### ğŸ§ª Example: `var` leaks outside `if` block

```js
if (true) {
  var color = 'blue';
}

console.log(color); // âœ… blue (even though it was inside the if block!)
```

ğŸ’¡ Even though `color` was inside `{ }`, it is still accessible outside.

##### ğŸ“Œ Point 3: `var` Can be Redeclared and Reassigned

With `var`, you can:

- **Redeclare** the same variable again in the same scope.
- **Reassign** a new value to the variable anytime.

This means JavaScript will **not complain** if you accidentally declare a variable twice using `var`.

###### ğŸ§ª Example: Redeclaring a variable with `var`

```javascript
var name = 'Sunil';
var name = 'Kumar'; // âœ… No error
console.log(name); // ğŸ‘‰ "Kumar"
```

ğŸ’¡ You declared `name` two times. JavaScript allows it when using `var`.

###### ğŸ§ª Example: Reassigning a new value

```javascript
var age = 20;
age = 21; // âœ… No problem
console.log(age); // ğŸ‘‰ 21
```

ğŸ’¡ You didnâ€™t declare `age` again, just gave it a new value â€” and that's allowed.

<Aside type="caution" title='Why avoid it?'>

It causes unexpected results due to hoisting and lack of block scope.

</Aside>

#### ğŸ§‘â€ğŸ’» `let` â€“ Modern and Safe

##### ğŸ“Œ Point 1: Block Scoped â€“ Only Works Inside `{ }`

When you use `let`, the variable works only inside the curly braces `{ }` where it was declared. This could be inside a loop, a function, or an `if` block.

###### ğŸ§ª Example 1: Block Scope with `let`

```javascript
{
  let message = 'Hello!';
  console.log(message); // âœ… Hello!
}
console.log(message); // âŒ Error: message is not defined
```

ğŸ’¡ `message` only exists inside the `{ }` block.

##### ğŸ“Œ Point 2: Can Be Reassigned but can't Be Redeclared

You can **change the value** of a `let` variable, but you **can't declare it again** in the same block or scope.

###### ğŸ§ª Example 2: Reassigning with `let`

```javascript
let age = 25;
age = 30; // âœ… OK
console.log(age); // ğŸ‘‰ 30
```

###### ğŸ§ª Example 3: Redeclaring in same scope â€“ Not allowed

```javascript
let name = 'Sunil';
// let name = "Kumar"; // âŒ Error: name has already been declared
```

ğŸ’¡ You can **change** the value, but you **can't declare** it again in the same scope.

##### ğŸ“Œ Point 3: Hoisted, But in TDZ â€“ Canâ€™t Use Before Declaring

Variables declared with `let` are hoisted, but they stay in a special phase called the **Temporal Dead Zone (TDZ)**. This means: You must declare it first before using it, or you'll get an error.

<Aside type="tip">

Use `let` **when the value will change** (like counters, loops, form values, etc.)

</Aside>

###### ğŸ§ª Example 4: Using before declaration â€“ Error

```javascript
// console.log(score); // âŒ Error: Cannot access 'score' before initialization
let score = 100;
```

###### ğŸ§ª Example 5: Correct way to use let

```javascript
let points = 50;
console.log(points); // âœ… 50
```

#### ğŸ”’ `const` â€“ Constant Value

##### ğŸ“Œ Point 1: Block Scoped â€“ Only Works Inside `{ }`

Just like `let`, variables declared with `const` only work **inside the curly braces** `{ }` where they are defined.

###### ğŸ§ª Example 1: Block scope with const

```javascript
{
  const greeting = 'Hi!';
  console.log(greeting); // âœ… Hi!
}
console.log(greeting); // âŒ Error: greeting is not defined
```

ğŸ’¡ `greeting` only exists inside the block `{ }`.

##### ğŸ“Œ Point 2: Cannot Be Reassigned or Redeclared

Once you set a value with `const`, you **cannot change it** (reassign) or declare it again in the same scope.

###### ğŸ§ª Example 2: Reassigning a `const` â€“ Not allowed

```javascript
const name = 'Sunil';
// name = "Kumar"; // âŒ Error: Assignment to constant variable
```

###### ğŸ§ª Example 3: Redeclaring a `const` â€“ Not allowed

```javascript
const age = 20;
// const age = 21; // âŒ Error: age has already been declared
```

Use `const` **by default**, unless the value needs to change.

<Aside type="tip" title='Note'>

If `const` is used with **objects or arrays**, the reference can't change, but properties **can**.

```javascript
const person = { name: 'Sunil' };
person.name = 'Kumar'; // âœ… allowed
```

</Aside>

#### ğŸ“Š Visual Cheatsheet

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>
        <code>var</code>
      </th>
      <th>
        <code>let</code>
      </th>
      <th>
        <code>const</code>
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Scope</td>
      <td>Function scoped</td>
      <td>Block scoped</td>
      <td>Block scoped</td>
    </tr>
    <tr>
      <td>Can be Redeclared?</td>
      <td>âœ… Yes</td>
      <td>âŒ No</td>
      <td>âŒ No</td>
    </tr>
    <tr>
      <td>Can be Reassigned?</td>
      <td>âœ… Yes</td>
      <td>âœ… Yes</td>
      <td>âŒ No</td>
    </tr>
    <tr>
      <td>Hoisted?</td>
      <td>
        âœ… Yes (with <code>undefined</code>)
      </td>
      <td>
        âœ… Yes (in TDZ<sup>* </sup>)
      </td>
      <td>
        âœ… Yes (in TDZ<sup>* </sup>)
      </td>
    </tr>
    <tr>
      <td>Use Before Declaration?</td>
      <td>âœ… Allowed</td>
      <td>âŒ Error</td>
      <td>âŒ Error</td>
    </tr>
    <tr>
      <td>Best For</td>
      <td>Old JS, rarely used now</td>
      <td>Changing values</td>
      <td>Fixed values</td>
    </tr>
  </tbody>
</table>

<Aside type="caution" title='Temporal Dead Zone'>

**TDZ** stands for **Temporal Dead Zone**. Itâ€™s the time between when a variable is hoisted and when it is actually declared in your code.

During this period, **you cannot use** variables declared with `let` or `const` â€” if you try, it will throw an error.

ğŸ§ª Example

```javascript
console.log(name); // âŒ Error: Cannot access 'name' before initialization
let name = 'Sunil';
```

`name` is hoisted but stuck in the **TDZ** until itâ€™s declared.

</Aside>

**Key Notes:**

- Use **`const`** by default.
- Use **`let`** if the value needs to change later.
- Avoid **`var`** in modern code.
